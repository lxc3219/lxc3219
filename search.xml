<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>类加载器</title>
    <url>/archives/70c5b892.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 20:43:45 GMT+0800 (GMT+08:00) --><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java 类加载器是 Java 运行时环境的一部分，负责动态加载描述 Java 类的<strong>二进制字节流</strong>到 Java 虚拟机的内存空间中。</p><a id="more"></a><p>这里的二进制字节流可以从以下场景中获取</p><ul><li>ZIP、JAR、EAR、WAR 包中读取。</li><li>从网络中获取，这种场景最典型的应用就是 Applet。</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，就是用了<code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成 <code>$Proxy</code> 的代理类的二进制字节流。</li><li>由其他文件生成，典型场景：JSP应用。</li><li>从数据库中读取，这种场景相对少见些，有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>类层次划分</li><li>OSGi</li><li>代码热替换（HotSwap）</li><li>模块热部署（HotDeployment）</li><li>代码加密</li></ul><h3 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h3><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h3><p>这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分。</p><ul><li>负责将存放在 <code>$JRE_HOME\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</li><li>启动类加载器无法被 Java 程序直接引用</li><li>所有类加载器的父类</li></ul><h3 id="其他类加载器"><a href="#其他类加载器" class="headerlink" title="其他类加载器"></a>其他类加载器</h3><p>这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><p>这个加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</p><ul><li>从 <code>$JRE_HOME\lib\ext</code> 目录下的 jar 文件加载类，可使用 <code>-Djava.ext.dirs</code> 命令设置 <code>java.ext.dirs</code> 系统属性来指定扩展类路径。</li><li>开发者可以直接使用扩展类加载器</li><li>System ClassLoader 的父类加载器</li></ul><h4 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h4><p>这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code> 来实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。</p><ul><li>负责加载 ClassPath 用户类路径上所指定的类库</li><li>开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>如果<strong>遵循双亲委派模型</strong>实现自定义类加载器的话，建议继承 <code>ClassLoader</code> 并重写 <code>findClass</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>类加载器的双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p><blockquote><p>注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。</p></blockquote><p><img src="/archives/70c5b892/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>这样具备优先级的层次关系可以<strong>避免类的重复加载，保证 Java 类在任何的类加载器中得到的都是同一个对象</strong>。</li><li>防止核心API库被随意篡改</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>根据双亲委派模型，在加载类文件的时候，子类加载器先检查请求的类是否已经被加载过，若没有加载，则将加载请求委托给它的父类加载器，父类加载器会检测自己是否已经加载过类，如果已经加载则加载过程结束，如果没有加载的话则请求继续向上传递直至 Bootstrap ClassLoader。如果请求向上委托过程中，如果始终没有检测到该类已经加载，则 Bootstrap ClassLoader 开始尝试<strong>从其对应路径中</strong>加载该类文件，如果失败则由子类加载器继续尝试加载，直至发起加载请求的子类加载器为止。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>实现双亲委派的代码位于 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 方法之中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">    	<span class="comment">// 首先，检查请求的类是否已经被加载过了，如果从 JVM 缓存中找到该类，则直接返回</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 遵循双亲委派模型，首先会通过递归从父类加载器开始找，直到父类加载器是 Bootstrap Classloader 为止</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">// 父类加载器不为空则调用父类加载器的loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父加载器为空则调用 Bootstrap Classloader </span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父类加载器抛出 ClassNotFoundException</span></span><br><span class="line">                <span class="comment">// 则说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载的时候，尝试调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">                <span class="comment">// 自定义类加载器时，建议重新此方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些 SPI 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由 BootstrapClassLoader 加载的；SPI实现的 Java 类一般是由AppClassLoader 来加载的。BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>使用线程上下文类加载器(Thread Context ClassLoader)，这个类加载器可以通过 java.lang.Thread 类的 <code>setContextClassLoaser()</code> 方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个。如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是 <strong>应用程序类加载器</strong>。</p><blockquote><p>通常我们可以通过 <code>Thread.currentThread().getClassLoader()</code> 和<code>Thread.currentThread().getContextClassLoader()</code> 获取线程上下文类加载器。</p></blockquote><p>有了线程上下文类加载器，父类加载器可以请求子类加载器去完成类加载的动作。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，<code>ClassLoader.getResources(String name)</code> 方法就是用于读取 jar 包中的资源文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取资源的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 BootstrapClassLoader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。</p></blockquote><p><em>下方代码块为 spring boot 扫描获取所有 jar 包 <code>META-INF/spring.factories</code> 的自动配置信息。</em></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解 Java 虚拟机</li><li>MyBatis 技术内幕</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>类加载器</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title>类的生命周期</title>
    <url>/archives/cdffca23.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。</p><p><img src="/archives/cdffca23/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p><a id="more"></a><blockquote><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。请注意这里写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p></blockquote><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p><blockquote><p>该阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p></blockquote><p>假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么变量 value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为 123 的动作将在初始化阶段才会被执行。</clinit></p><p>假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>如果类字段的字段属性表中存在 ConstantValue 属性，编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将value赋值为 123。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li>符号引用（Symbolic References）<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li><li>直接引用（Direct References）<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解 Java 虚拟机</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>读书笔记</tag>
        <tag>深入理解 Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Jsonp 解决 Ajax 跨域问题</title>
    <url>/archives/bc00aec7.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互。<strong>所谓同源是指”协议+域名+端口”三者相同。</strong></p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域。</p><a id="more"></a><p><strong>跨域有以下限制：</strong></p><ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 等存储型内容</li><li>无法接触非同源网页的 DOM节点</li><li>无法向非同源地址发送 AJAX 请求</li></ul><h3 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h3><p>解决跨域的方法很多，大致有以下下几种：</p><ul><li>Jsonp（只支持 get 请求）</li><li><strong>CORS</strong></li><li>Iframe</li><li><strong>Proxy</strong></li></ul><p>本文先介绍使用 Jsonp 解决 Ajax 跨域问题，后续还会有 CORS、Proxy 解决跨域的文章。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">    jsonp: <span class="string">'callback'</span>,</span><br><span class="line">    jsonpCallback: <span class="string">'callback'</span> </span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;).error(<span class="function"><span class="keyword">function</span> (<span class="params">XMLHttpRequest,textStatus,errorThrown</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'fail'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>type</strong>： jsonp 只支持 get 请求<br><strong>dataType</strong>：设定为 <code>jsonp</code><br><strong>jsonp</strong>： 若无显示指定，默认为 <code>callback</code>，传递给后台，用以获取 jsonp 的回调函数名<br><strong>jsonpCallback</strong>：jsonp 的回调函数名，若无显示指定，则自动生成类似 <code>jQuery11100431856629965818_1585317491198</code> 的随机函数名</p></blockquote><p>该请求会自动在 url 后追加 <code>?callback=callbackMethodName&amp;_=1585317491199</code>，其中 <code>callback</code> 即为 <code>jsonp</code> 的属性值，<code>callbackMethodName</code> 即为 <code>jsonpCallback</code> 的属性值。主要作用是告诉服务器我的本地回调函数叫做 callbackMethodName，请要把查询结果传入这个函数中，即 <code>callbackMethodName({&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:18})</code> 这种形式。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CommonResult commonResult = <span class="keyword">new</span> CommonResult();</span><br><span class="line">    String responseStr = JSONObject.toJSONString(commonResult);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"callback"</span> + <span class="string">"("</span> + responseStr + <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“callback” 需要跟 Ajax 中 jsonpCallback 的属性值一致</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用 FastJson 提供的 <code>com.fasterxml.jackson.databind.util.JSONPObject</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONPObject <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CommonResult commonResult = <span class="keyword">new</span> CommonResult();</span><br><span class="line">    JSONPObject jo = <span class="keyword">new</span> JSONPObject(<span class="string">"callback"</span>, commonResult);</span><br><span class="line">    <span class="keyword">return</span> jo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“callback” 需要跟 Ajax 中 jsonpCallback 的属性值一致</p></blockquote><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><strong>FastJson 对 Jsonp 提供了支持</strong></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>本实验环境为 SpringBoot 2.1.5.RELEASE，FastJson 1.2.58，采用 Java Config 形式实现。其他版本以及其他形式配置请参考<a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson" target="_blank" rel="noopener external nofollow noreferrer">在 Spring 中集成 Fastjson</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 FastJson 作为默认的 java 对象与 json 互相转换的工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="comment">// 创建配置类</span></span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        <span class="comment">// 自定义格式化输出</span></span><br><span class="line">        config.setSerializerFeatures(</span><br><span class="line">                SerializerFeature.DisableCircularReferenceDetect,</span><br><span class="line">                SerializerFeature.WriteMapNullValue,</span><br><span class="line">                SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">                SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">                SerializerFeature.WriteNullBooleanAsFalse);</span><br><span class="line">        <span class="comment">// 处理中文乱码问题</span></span><br><span class="line">        List&lt;MediaType&gt; fastMediaTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">        converter.setSupportedMediaTypes(fastMediaTypes);</span><br><span class="line">        converter.setFastJsonConfig(config);</span><br><span class="line">        converters.add(<span class="number">0</span>, converter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 JSONP 支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONPResponseBodyAdvice <span class="title">jsonpResponseBodyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSONPResponseBodyAdvice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用的 FastJson 版本小于 1.2.36 的话(强烈建议使用最新版本)，在与 Spring MVC 4.X 版本集成时需使用 FastJsonHttpMessageConverter4。</p></blockquote><blockquote><p>SpringBoot 2.0.1 版本中加载 WebMvcConfigurer 的顺序发生了变动，故需使用 <code>converters.add(0, converter);</code> 指定 FastJsonHttpMessageConverter 在 converters 内的顺序，否则在 SpringBoot 2.0.1 及之后的版本中将优先使用 Jackson 处理。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Fastjson 提供了 <code>@ResponseJSONP</code> 注解，该注解组合了 <code>@ResponseBody</code>，也就意味着使用了 <code>@ResponseJSONP</code> 就没必要再添加 <code>@ResponseBody</code> 了。另外该注解有个 <code>callback</code> 成员变量（默认值为 <code>callback</code> ），即为 Ajax 中 <code>jsonp</code> 属性值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ResponseJSONP &#123;</span><br><span class="line">    <span class="function">String <span class="title">callback</span><span class="params">()</span> <span class="keyword">default</span> "callback"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseJSONP 可以修饰类或方法，若修饰在类上则该类下所有方法都生效，方法上优先级大于类。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseJSONP</span> <span class="comment">// 类级别</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsonp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonpController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseJSONP</span>(callback = <span class="string">"callback"</span>) <span class="comment">// 方法级别</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order</span>(-<span class="number">2147483648</span>)</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONPResponseBodyAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JSONPResponseBodyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前消息转换器为 FastJsonHttpMessageConverter 同时类或方法上有 @ResponseJSONP 注解，才会进行返回体封装</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FastJsonHttpMessageConverter<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">converterType</span>) &amp;&amp; (<span class="title">returnType</span>.<span class="title">getContainingClass</span>().<span class="title">isAnnotationPresent</span>(<span class="title">ResponseJSONP</span>.<span class="title">class</span>) || <span class="title">returnType</span>.<span class="title">hasMethodAnnotation</span>(<span class="title">ResponseJSONP</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获取方法上的注解</span></span><br><span class="line">        ResponseJSONP responseJsonp = (ResponseJSONP)returnType.getMethodAnnotation(ResponseJSONP<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (responseJsonp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若方法上不存在则获取类上的注解</span></span><br><span class="line">            responseJsonp = (ResponseJSONP)returnType.getContainingClass().getAnnotation(ResponseJSONP<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest servletRequest = ((ServletServerHttpRequest)request).getServletRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据设置的 callback 获取请求中的 callbackMethodName 回调函数名</span></span><br><span class="line">        String callbackMethodName = servletRequest.getParameter(responseJsonp.callback());</span><br><span class="line">        <span class="keyword">if</span> (!IOUtils.isValidJsonpQueryParam(callbackMethodName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Invalid jsonp parameter value:"</span> + callbackMethodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            callbackMethodName = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包装成类似 callbackMethodName(&#123;"name":"xiaoming","age":18&#125;)</span></span><br><span class="line">        JSONPObject jsonpObject = <span class="keyword">new</span> JSONPObject(callbackMethodName);</span><br><span class="line">        jsonpObject.addParameter(body);</span><br><span class="line">        <span class="keyword">this</span>.beforeBodyWriteInternal(jsonpObject, selectedContentType, returnType, request, response);</span><br><span class="line">        <span class="keyword">return</span> jsonpObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeBodyWriteInternal</span><span class="params">(JSONPObject jsonpObject, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MediaType <span class="title">getContentType</span><span class="params">(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FastJsonHttpMessageConverter.APPLICATION_JAVASCRIPT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>从上面源码可以看出返回体封装必须要求<strong>当前消息转换器为 FastJsonHttpMessageConverter</strong>，也就是必须要将 FastJsonHttpMessageConverter 作为默认的 json 与 java 对象的转换器。但是有些公司内部禁止使用 FastJson，这个时候我们可以仿照上面的源码自定义 JSONPResponseBodyAdvice 实现 ResponseBodyAdvice，重写 supports 和 beforeBodyWrite 方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson" target="_blank" rel="noopener external nofollow noreferrer">在 Spring 中集成 Fastjson</a></li><li><a href="https://blog.csdn.net/hansexploration/article/details/80314948" target="_blank" rel="noopener external nofollow noreferrer">jsonp原理详解——终于搞清楚jsonp是啥了</a></li><li><a href="https://blog.csdn.net/qq_38128179/article/details/84956552" target="_blank" rel="noopener external nofollow noreferrer">什么是跨域？跨域解决方法</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>faq</tag>
        <tag>jsonp</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 源码阅读环境准备</title>
    <url>/archives/b22ae826.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><blockquote><p>作者：d3f59bfc7013<br>链接：<a href="https://www.jianshu.com/p/e739afb8fe31" target="_blank" rel="noopener external nofollow noreferrer">https://www.jianshu.com/p/e739afb8fe31</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>阅读源码是提升自己代码能力的一个非常重要的手段，但是源码阅读有时候也非常麻烦，一定要找到入口点，然后动态地去看代码，一步步调试然后画图做笔记记录，才能在一团乱中清理出一个道路来。这篇文章介绍了我在阅读 MyBatis 源码的准备过程。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis 是一个流行的半自动映射框架，之所以称为半自动框架是因为它需要手工匹配 Java 类，SQL 和映射关系，而全表映射的 Hibernate 只需要提供 POJO 和映射关系就可以了。区别如下表：</p><table><thead><tr><th>MyBatis</th><th>Hibernate</th></tr></thead><tbody><tr><td>Java类</td><td>Java类</td></tr><tr><td>映射规则</td><td>映射规则</td></tr><tr><td>SQL</td><td>无</td></tr></tbody></table><p>通过上表也可以看出，Hibenate 无需编写 SQL，所以开发效率优于 MyBatis。此外，它提供缓存、日志、级联等功能。但是缺点也是十分明显，多表关联复杂的 SQL，根据条件变化的 SQL。存储过程等场景使用 Hibenate 非常不便，而性能又难以通过 SQL 优化。所以注定 Hibernate 只适用于场景不太复杂，要求性能不太苛刻的时候使用。如果你需要一个灵活的、可以动态生成映射关系的框架，那么 MyBatis 是一个最好的选择。</p><h2 id="组件以及执行基本流程"><a href="#组件以及执行基本流程" class="headerlink" title="组件以及执行基本流程"></a>组件以及执行基本流程</h2><ul><li>SqlSessionFactoryBuilder（构造器）:它会根据配置信息或者代码生成 SqlSessionFactory（工厂接口）</li><li>SqlSessionFactory：依靠工厂来生成 SqlSession。</li><li>SqlSession：是一个既可以发送 SQL 去执行并返回结果的，也可以获取 Mapper 接口，通过 Mapper 接口查询并封装数据。</li><li>SQL Mapper:它是 MyBatis 新设计的组件，它是由一个 Java 接口和 XML 文件（或者注解)构成的，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，并返回结果。</li></ul><p>用下图表达上述组件之间的关联</p><p><img src="/archives/b22ae826/MyBatis%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt></p><h2 id="源码阅读准备"><a href="#源码阅读准备" class="headerlink" title="源码阅读准备"></a>源码阅读准备</h2><ul><li>github 上有一个中文注释版的MyBatis源码。<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftuguangquan%2FMyBatis.git" target="_blank" rel="noopener external nofollow noreferrer">MyBatis中文链接</a></li><li>MyBatis 是以 Maven 管理的，依赖于 mybatis-parent 模块。<strong>将 MyBatis 导入到 IDEA 中时，也需要将 mybatis-parent 模块导入。</strong><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FMyBatis%2Fparent.git" target="_blank" rel="noopener external nofollow noreferrer">mybatis-parent 模块链接</a></li><li>将模块 MyBatis，mybatis-parent 模块导入到 IDEA 中，接下来就通过 MyBatis 的最基本的代码来调试并阅读 MyBatis 源码。整个结构如下图。</li></ul><p><img src="/archives/b22ae826/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt></p><p>通过《深入浅出 MyBatis 技术原理与实战》一书的代码来实现基本调试。代码的目录请看上图，代码的内容下面一一列出。</p><p>数据库表 role</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`role`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`role_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of role</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`role`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'张三'</span>, <span class="string">'张三的备注'</span>);</span><br></pre></td></tr></table></figure><p>数据库表 role 对应的实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author gethin</span></span><br><span class="line"><span class="comment"> * 角色的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    ...</span><br><span class="line">    getter setter省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RoleMapper 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author gethin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">findRole</span><span class="params">(String roleName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RoleMapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//MyBatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://MyBatis.org/dtd/MyBatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gethin.mapper.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"role"</span> <span class="attr">id</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"long"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"role_name"</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">javaType</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">typeHandler</span>=<span class="string">"com.gethin.handler.MyStringHandler"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        id,role_name as roleName,note from role where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        id,role_name,note from role where role_name like CONCAT('%',#&#123;roleName</span><br><span class="line">        javaType=string,</span><br><span class="line">        jdbcType=VARCHAR,typeHandler=com.gethin.handler.MyStringHandler&#125;,'%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">        insert into</span><br><span class="line">        role(role_name,note) value(#&#123;roleName&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">        delete from role where</span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MyStringHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedTypes</span>(&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">MappedJdbcTypes</span>(<span class="title">JdbcType</span>.<span class="title">VARCHAR</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyStringHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log=Logger.getLogger(MyStringHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(ResultSet rs, String colName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"使用我的TypeHandler,ResultSet列名获取字符串"</span>);</span><br><span class="line">        <span class="keyword">return</span> rs.getString(colName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"使用我的TypeHandler,ResultSet下标获取字符串"</span>);</span><br><span class="line">        <span class="keyword">return</span> rs.getString(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"使用我的TypeHandler,CallableStatement下标获取字符串"</span>);</span><br><span class="line">        <span class="keyword">return</span> cs.getString(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> index, String value, JdbcType arg3)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"使用我的TypeHandler"</span>);</span><br><span class="line">        ps.setString(index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log4j.properties 配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;DEBUG,stdout</span><br><span class="line">log4j.logger.org.MyBatis&#x3D;DUBUG</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logDailyFile.layout.ConversionPattern &#x3D; %5p %d %C:%m%n</span><br></pre></td></tr></table></figure><p>MyBatis-config.xml 配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//MyBatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://MyBatis.org/dtd/MyBatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;setting name="aggressiveLazyLoading" value="false"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.gethin.po.Role"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">javaType</span>=<span class="string">"string"</span> <span class="attr">handler</span>=<span class="string">"com.gethin.handler.MyStringHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据库的信息，默认使用development数据库构建环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/MyBatis"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dbuser"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.gethin.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>阅读以及 debug 入口 （Main）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String resource=<span class="string">"MyBatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory=<span class="keyword">null</span>;</span><br><span class="line">        sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sqlSession=sqlSessionFactory.openSession();</span><br><span class="line">            RoleMapper roleMapper=sqlSession.getMapper(RoleMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Role role=roleMapper.getRole(<span class="number">1L</span>);</span><br><span class="line">            System.out.println(role.getId()+<span class="string">":"</span>+role.getRoleName()+<span class="string">":"</span>+role.getNote());</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            sqlSession.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过执行 Main 类，并设立断点，就可以一步一步进行源码的调试以及阅读了。</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/archives/7b510e10.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="代理概念"><a href="#代理概念" class="headerlink" title="代理概念"></a>代理概念</h2><p>为某个对象提供一个代理，并由代理对象控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介的作用，既保护了目标对象，同时也在一定程度上减少了系统的耦合度。</p><a id="more"></a><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><img src="/archives/7b510e10/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt></p><ul><li><p>代理接口（Subject）：声明真实对象和代理对象的共同接口。</p></li><li><p>代理主题（ProxySubject）：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p></li><li><p>委托主题（RealSubject）：代理角色所代表的真实对象，是我们最终要引用的对象。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</p><p><strong>根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。</strong></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</strong></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多。同时一旦接口增加方法,，标对象与代理对象都要维护。增加了代码维护的复杂度。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托主题，具体处理业务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是委托方..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代理主题持有委托类的对象引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以扩展，增加一些查询之前需要执行的方法</span></span><br><span class="line">        System.out.println(<span class="string">"代理主题预处理..."</span>);</span><br><span class="line">        </span><br><span class="line">        delegate.deal();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以扩展，增加一些查询之后需要执行的方法</span></span><br><span class="line">        System.out.println(<span class="string">"代理主题后续处理..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理静态工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectStaticFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户类调用此工厂方法获得代理对象</span></span><br><span class="line"><span class="comment">     * 对客户类来说，他其实并不知道返回的是代理主题类对象还是委托主题类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Subject delegate = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxySubject(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject proxySubject = SubjectStaticFactory.getInstance();</span><br><span class="line">        proxySubject.deal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理（接口代理）"><a href="#动态代理（接口代理）" class="headerlink" title="动态代理（接口代理）"></a>动态代理（接口代理）</h2><p><strong>动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</strong></p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>动态代理与静态代理相比，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>动态生成的代理类有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托主题，具体处理业务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是委托方..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类对应的调用处理程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代理主题持有委托类的对象引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectInvocationHandler</span><span class="params">(Subject delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以扩展，增加一些查询之前需要执行的方法</span></span><br><span class="line">        System.out.println(<span class="string">"代理主题预处理..."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用反射机制将请求分派给委托类处理。Method的invoke返回Object对象作为方法执行结果。</span></span><br><span class="line">        method.invoke(delegate, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以扩展，增加一些查询之后需要执行的方法</span></span><br><span class="line">        System.out.println(<span class="string">"代理主题后续处理..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理动态工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户类调用此工厂方法获得代理对象</span></span><br><span class="line"><span class="comment">     * 对客户类来说，他其实并不知道返回的是代理主题类对象还是委托主题类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Subject delegate = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> SubjectInvocationHandler(delegate);</span><br><span class="line">        Subject proxy = <span class="keyword">null</span>;</span><br><span class="line">        proxy = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                delegate.getClass().getClassLoader(),</span><br><span class="line">                delegate.getClass().getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理客户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> luoxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject proxy = DynProxyFactory.getInstance();</span><br><span class="line">        proxy.deal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理类部分反编译代码"><a href="#动态代理类部分反编译代码" class="headerlink" title="动态代理类部分反编译代码"></a>动态代理类部分反编译代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> org.melody.demo.design.pattern.proxy.dynamic.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m3 = Class.forName(<span class="string">"org.melody.demo.design.pattern.proxy.dynamic.Subject"</span>).getMethod(<span class="string">"deal"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException localError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zpf336/article/details/82751925" target="_blank" rel="noopener external nofollow noreferrer">动态代理与静态代理区别</a></li><li><a href="https://www.cnblogs.com/zhangchengzi/p/9713807.html" target="_blank" rel="noopener external nofollow noreferrer">JAVA设计模式-动态代理(Proxy)源码分析</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title>八个字</title>
    <url>/archives/9d80e908.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>苦，才是生活。<br>累，才是工作。<br>变，才是命运。<br>忍，才是历练。<br>容，才是智慧。<br>静，才是修养。<br>舍，才会得到。<br>做，才会拥有。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>短文学</category>
      </categories>
      <tags>
        <tag>短文学</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 集成和移除自定义的 Maven 骨架</title>
    <url>/archives/25be9ab7.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>本文描述的是 IntelliJ IDEA 集成和移除自定义的 Maven 骨架的操作流程。</p><blockquote><p><strong>注意：本文描述是在 Windows 环境下操作的，Linux、MAC 可能有所出入。</strong></p></blockquote><a id="more"></a><h2 id="添加骨架"><a href="#添加骨架" class="headerlink" title="添加骨架"></a>添加骨架</h2><p>在 IntelliJ IDEA 中按照以下流程操作即可</p><ul><li>新建项目 <code>File &gt; New &gt; Project</code></li><li>选择 Maven 并勾选 <code>Create from archetype</code></li><li>点击 <code>Add Archetype</code> 按钮</li><li>填写 <code>GroupId</code></li><li>填写 <code>ArtifactId</code></li><li>填写 <code>Version</code></li><li>点击 <code>OK</code></li></ul><blockquote><p><code>Add Archetype</code> 步骤只需执行一次，以后可直接选择对应的骨架创建项目。</p></blockquote><p><img src="/archives/25be9ab7/maven%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E6%93%8D%E4%BD%9C1.png" alt><br><img src="/archives/25be9ab7/maven%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E6%93%8D%E4%BD%9C2.png" alt></p><h2 id="移除骨架"><a href="#移除骨架" class="headerlink" title="移除骨架"></a>移除骨架</h2><p>在 <code>C:\Users\${user}.IntelliJIdea${version}\system\Maven\Indices</code> 中找到 UserArchetypes.xml 文件，删除对应的 maven 骨架配置信息，重启IntelliJ IDEA 生效。</p><p><img src="/archives/25be9ab7/maven%E7%A7%BB%E9%99%A4%E9%AA%A8%E6%9E%B6%E6%93%8D%E4%BD%9C.png" alt></p><p>到此为止，在 IntelliJ IDEA 中集成和移除自定义的 Maven 骨架的操作就结束了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>可能有些朋友是使用 <code>mvn archetype:generate -DarchetypeCatalog=local</code> 命令生成项目，这种交互模式会在选择列表展示本地的所有 Maven 骨架，包括一些测试实验性质的骨架。所以我们要将其彻底删除。</p><p><strong>进入本地仓库目录找到对应的骨架删除即可</strong></p><blockquote><p>本地仓库默认 <code>${user.home}/.m2/repository</code><br>若特别设置过忘记的话，可查看 <code>${MAVEN_HOME}\conf\settings.xml</code> 文件中的 localRepository 标签信息</p></blockquote><p><img src="/archives/25be9ab7/maven%E5%88%A0%E9%99%A4%E9%AA%A8%E6%9E%B6%E6%96%87%E4%BB%B6.png" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>intellij idea</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 驱动 com.mysql.cj.jdbc.Driver</title>
    <url>/archives/89094d45.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="两种驱动"><a href="#两种驱动" class="headerlink" title="两种驱动"></a>两种驱动</h2><p>MySQL 驱动的类型跟驱动的版本有关，其中 <code>com.mysql.jdbc.Driver</code> 是 <code>mysql-connector-java 5</code> 中的，<code>com.mysql.cj.jdbc.Driver</code> 是 <code>mysql-connector-java 6.x</code> 以及后续版本支持的。</p><a id="more"></a><h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p><strong>mysql-connector-java 8.x支持mysql 5.6,5.7,5.8</strong></p><p><img src="/archives/89094d45/%E9%A9%B1%E5%8A%A8%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81.png" alt></p><h2 id="com-mysql-cj-jdbc-Driver"><a href="#com-mysql-cj-jdbc-Driver" class="headerlink" title="com.mysql.cj.jdbc.Driver"></a>com.mysql.cj.jdbc.Driver</h2><p><strong>使用 com.mysql.cj.jdbc.Driver 驱动需要指定时区 serverTimezone</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8mb4&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;root</span><br></pre></td></tr></table></figure><blockquote><p>serverTimezone=UTC：比中国时间早8个小时<br>serverTimezone=GMT%2B8：中国时区，%2B是“+”<br>serverTimezone=Asia/Hongkong：中国时区<br>serverTimezone=Asia/Shanghai：中国时区</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 加载本地依赖并打包</title>
    <url>/archives/758bf931.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>本文描述的是 spring boot 项目如何加载本地依赖并且打包的过程。</p><a id="more"></a><h2 id="加载本地依赖"><a href="#加载本地依赖" class="headerlink" title="加载本地依赖"></a>加载本地依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aspose.words<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspose-words-jdk16<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>16.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/aspose-words-jdk16-16.8.0.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>scope 的值要设置为 system<br>systemPath 的值，指向 jar 的路径</p></blockquote><h2 id="将本地依赖打进包"><a href="#将本地依赖打进包" class="headerlink" title="将本地依赖打进包"></a>将本地依赖打进包</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span>        </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>            </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>        </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>         </span><br><span class="line">                <span class="comment">&lt;!-- 将 scope=system 的依赖打进包里去 --&gt;</span>            </span><br><span class="line">                <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span>                   </span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 切换镜像源</title>
    <url>/archives/82d4c19.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>默认情况下，Maven 是去国外的中央仓库下载所需的依赖，在没有 VPN 的协助下，访问的速度很慢。故要将镜像源切换为国内的镜像源，以提高访问速度。<br>此处推荐使用<strong>阿里的镜像源</strong>（<a href="http://maven.aliyun.com/nexus/content/groups/public）" target="_blank" rel="noopener external nofollow noreferrer">http://maven.aliyun.com/nexus/content/groups/public）</a></p><a id="more"></a><h2 id="切换镜像源"><a href="#切换镜像源" class="headerlink" title="切换镜像源"></a>切换镜像源</h2><h3 id="全局生效"><a href="#全局生效" class="headerlink" title="全局生效"></a>全局生效</h3><p>在 <code>${MAVEN_HOME}\conf\settings.xml</code> 文件的 <code>&lt;/mirrors&gt;...&lt;/mirrors&gt;</code> 内部加入以下代码</p><blockquote><p>Maven 安装路径忘记的话可以在 cmd 控制台输入 <code>mvn -v</code> 查看</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimvn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="当前项目生效"><a href="#当前项目生效" class="headerlink" title="当前项目生效"></a>当前项目生效</h3><p>在工程的 pom.xml 中添加以下内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他镜像源"><a href="#其他镜像源" class="headerlink" title="其他镜像源"></a>其他镜像源</h2><ul><li><a href="http://www.sonatype.org/nexus/" target="_blank" rel="noopener external nofollow noreferrer">http://www.sonatype.org/nexus/</a></li><li><a href="http://mvnrepository.com/" target="_blank" rel="noopener external nofollow noreferrer">http://mvnrepository.com/</a></li><li><a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener external nofollow noreferrer">http://repo1.maven.org/maven2</a></li><li><a href="http://repo2.maven.org/maven2/" target="_blank" rel="noopener external nofollow noreferrer">http://repo2.maven.org/maven2/</a></li><li><a href="http://uk.maven.org/maven2/" target="_blank" rel="noopener external nofollow noreferrer">http://uk.maven.org/maven2/</a></li><li><a href="http://repository.jboss.org/nexus/content/groups/public" target="_blank" rel="noopener external nofollow noreferrer">http://repository.jboss.org/nexus/content/groups/public</a></li><li><a href="http://maven.oschina.net/content/groups/public/" target="_blank" rel="noopener external nofollow noreferrer">http://maven.oschina.net/content/groups/public/</a></li><li><a href="http://maven.antelink.com/content/repositories/central/" target="_blank" rel="noopener external nofollow noreferrer">http://maven.antelink.com/content/repositories/central/</a></li><li><a href="http://nexus.openkoala.org/nexus/content/groups/Koala-release/" target="_blank" rel="noopener external nofollow noreferrer">http://nexus.openkoala.org/nexus/content/groups/Koala-release/</a></li><li><a href="http://maven.tmatesoft.com/content/groups/public/" target="_blank" rel="noopener external nofollow noreferrer">http://maven.tmatesoft.com/content/groups/public/</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 依赖冲突</title>
    <url>/archives/9f7de2dd.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="为什么会冲突？"><a href="#为什么会冲突？" class="headerlink" title="为什么会冲突？"></a>为什么会冲突？</h2><ol><li>每个 Java 项目都是一系列 Java 程序的集合，或多或少会引用一些第三方依赖。</li><li>在同一个类加载器中，相同全限定类名的 Class 只会被加载一次。</li><li>加载到 JVM 中的这个类未必就是我们需要的版本（需要高版本却选择了低版本、依赖不向下兼容）</li></ol><a id="more"></a><blockquote><p>JVM 有类加载机制，有双亲委派模型，它保证了 Java 类加载的安全性，例如 JDK 中核心类库通过 BootstrapClassloader 去加载，我们编写的代码是无法改写 JVM 中的核心类，从而保证了安全性。Maven 加载类也是通过其自定义的类加载器进行，在同一个类加载器中，相同全限定类名的 Class 只会被加载一次，因此不可能出现一个相同的类名，两个不同版本的类在一个 JVM 中（<strong>除非两个版本是不同的类加载器加载的</strong>）。</p></blockquote><h2 id="Maven-的仲裁机制"><a href="#Maven-的仲裁机制" class="headerlink" title="Maven 的仲裁机制"></a>Maven 的仲裁机制</h2><p>通过 Maven 引入的 Jar 包，Maven 有<strong>路径最短原则以及定义顺序原则和覆写优先原则</strong>保证了由 Maven引入的 jar 包是唯一的，并且可以通过此规则判断出最终加载到 JVM 的是哪个版本。</p><h3 id="1-路径最短原则"><a href="#1-路径最短原则" class="headerlink" title="1. 路径最短原则"></a>1. 路径最短原则</h3><p>若无版本声明，则按照“短路径优先”的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本</p><h3 id="2-定义顺序原则"><a href="#2-定义顺序原则" class="headerlink" title="2. 定义顺序原则"></a>2. 定义顺序原则</h3><p>若路径长度一致，则按照“第一声明优先”的原则进行仲裁，即选择 POM 中最先声明的版本</p><h3 id="3-覆写优先原则"><a href="#3-覆写优先原则" class="headerlink" title="3. 覆写优先原则"></a>3. 覆写优先原则</h3><p>优先按照依赖管理<dependencymanagement>元素中指定的版本声明进行仲裁，此时下面的两个原则都无效了</dependencymanagement></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ol><li>通过 Maven Helper 插件查看依赖树，手动 exclude 掉不需要的版本</li><li>通过 dependencyManagement 指定统一的版本，子类只需要指定包名即可复用父类的版本号，避免不必要的混乱。</li><li>类隔离机制：使用不同的 ClassLoader 加载不同版本的三方依赖，进而隔离包冲突问题<ol><li><a href="https://github.com/sofastack/sofa-ark" target="_blank" rel="noopener external nofollow noreferrer">蚂蚁金服的 SOFAArk</a></li><li>OSGI</li></ol></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/v-mbc5EXQ-kVrcb2o6kSBw" target="_blank" rel="noopener external nofollow noreferrer">https://mp.weixin.qq.com/s/v-mbc5EXQ-kVrcb2o6kSBw</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 上传本地依赖至远程仓库</title>
    <url>/archives/78861363.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn deploy:deploy-file -DgroupId=com.ibm -DartifactId=connector -Dversion=1.0.0 -Dpackaging=jar -Dfile=D:\ibm\connector\1.0.0\connector-1.0.0.jar -Durl=http://192.168.1.1:8081/repository/3rdparty/ -DrepositoryId=3rdparty</span><br></pre></td></tr></table></figure><blockquote><p>-DgroupId：依赖的 groupId<br>-DartifactId：依赖的 artifactId<br>-Dversion：依赖的 version<br>-Dpackaging：依赖的格式<br>-Dfile：依赖的本地存储位置<br>-Durl：远程仓库位置<br>-DrepositoryId：远程仓库 Id</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 单继承及依赖杂乱问题</title>
    <url>/archives/c74431b2.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol><li>单继承<br>maven 的继承模式属于单继承，也就是说子 model 中只能出现一个 parent 标签。</li><li>依赖杂乱<br>parent 模块中，dependencyManagement 中预定义太多的依赖，造成 pom 文件过长，而且很乱。</li></ol><a id="more"></a><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p><strong>要求 maven2.9 以上版本</strong></p><ol><li>根据单一职责原则，将 dependency 分类，每一类建立单独的 pom 文件</li><li>在需要使用到这些依赖的子 model 中，使用 dependencyManagement 管理依赖，并 import scope 依赖</li></ol><blockquote><p>注意：<code>&lt;scope&gt;import&lt;/scope&gt;</code> 只能用在 dependencyManagement 里面，且仅用于 <code>&lt;type&gt;pom&lt;/type&gt;</code> 的 dependency</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/huahua035/p/7680607.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/huahua035/p/7680607.html</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>全局异常处理实现方案</title>
    <url>/archives/d830ded1.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>全局统一返回实现方案</title>
    <url>/archives/e5e17584.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 spring boot 启动器</title>
    <url>/archives/859d1044.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>Spring 官方 Starter 命名为 <code>spring-boot-starter-{name}</code>。<br>非官方 Starter 命名应遵循 <code>{name}-spring-boot-starter</code> 的格式。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Spring Boot 项目在启动时会扫描项目所依赖的 JAR 包，寻找这些 JAR 包的 META-INF 文件夹下的 spring.factories 文件，根据 spring.factories 文件的配置信息加载对应的 AutoConfigure 类，然后根据 @Conditional 系列注解，进行自动配置并将类实例注入到 IOC 容器。</p><a id="more"></a><h2 id="demo-spring-boot-starter"><a href="#demo-spring-boot-starter" class="headerlink" title="demo-spring-boot-starter"></a>demo-spring-boot-starter</h2><p>创建名为 <code>demo-spring-boot-starter</code> 的 maven 工程，在其中分别创建 People、PeopleProperties、PeopleAutoConfigure 类以及 spring.factories 文件。</p><h3 id="创建-People-类"><a href="#创建-People-类" class="headerlink" title="创建 People 类"></a>创建 People 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.suifeng.demo.spring.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String gender;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, String gender)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.name = name;        </span><br><span class="line">        <span class="keyword">this</span>.gender = gender;    </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-PeopleProperties-类"><a href="#创建-PeopleProperties-类" class="headerlink" title="创建 PeopleProperties 类"></a>创建 PeopleProperties 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.suifeng.demo.spring.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"people"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleProperties</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-PeopleAutoConfigure-类"><a href="#创建-PeopleAutoConfigure-类" class="headerlink" title="创建 PeopleAutoConfigure 类"></a>创建 PeopleAutoConfigure 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.suifeng.demo.spring.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.suifeng.demo.spring.boot.People;</span><br><span class="line"><span class="keyword">import</span> org.suifeng.demo.spring.boot.PeopleProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(People<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">PeopleProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PeopleAutoConfigure</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    PeopleProperties peopleProperties;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>    </span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>    </span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"people"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">people</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> People(peopleProperties.getName(), peopleProperties.getGender());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-spring-factories"><a href="#配置-spring-factories" class="headerlink" title="配置 spring.factories"></a>配置 spring.factories</h3><p>在静态资源文件夹下创建 resources/META-INF/spring.factories 文件，文件内容如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;org.suifeng.demo.spring.boot.PeopleAutoConfigure</span><br></pre></td></tr></table></figure><blockquote><p>“=” 左边的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 为 <code>EnableAutoConfiguration</code> 注解的类名全限定名，在这个配置文件中为固定值。</p><p>“=” 右边的 <code>org.suifeng.demo.spring.boot.PeopleAutoConfigure</code> 为自定义 AutoConfigure 配置类的全限定名，多个的话用“,”分隔开。</p></blockquote><h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p>执行 <code>mvn clean install</code> 命令生成 demo-spring-boot-starter.jar 并部署到本地仓库，供其他程序调用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>到此为止，一个简版的 demo-spring-boot-starter 启动器编码工作就完成了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>创建一个 spring boot 工程，在 pom.xml 中引入 demo-spring-boot-starter 依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.suifeng.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此处请根据各自的 maven 工程信息引入依赖</p></blockquote><h3 id="配置-yaml-属性"><a href="#配置-yaml-属性" class="headerlink" title="配置 yaml 属性"></a>配置 yaml 属性</h3><p>在 application.yaml 中添加如下属性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">people:</span>  </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">小花</span>  </span><br><span class="line">    <span class="attr">gender:</span> <span class="string">女</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 “:” 右边有个空格</p></blockquote><h3 id="创建-StarterController-类"><a href="#创建-StarterController-类" class="headerlink" title="创建 StarterController 类"></a>创建 StarterController 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.suifeng.demo.project.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.suifeng.demo.spring.boot.People;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/starter"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarterController</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> People people;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greet"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(people.greet());    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，调用请求看看~~</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>短</title>
    <url>/archives/d5256b7.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><blockquote class="blockquote-center"><p>一天很短，<br>短得来不及拥抱清晨，<br>就已经手握黄昏。</p><p>一年很短，<br>短得来不及细品初春殷红窦绿，<br>就要打点素裹秋霜。</p><p>一生很短，<br>短的来不及享用美好年华，<br>就已经身处迟暮。</p><p>总是经过的太快，<br>领悟的太晚，<br>我们要学会珍惜。</p><p>珍惜人生路上的亲情、友情、<br>同事情、同学情、朋友情。<br>一旦擦身而过，<br>也许永不邂逅。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>短文学</category>
      </categories>
      <tags>
        <tag>短文学</tag>
      </tags>
  </entry>
  <entry>
    <title>未选择的路</title>
    <url>/archives/8abcc3ae.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p><img src="/archives/8abcc3ae/road.png" alt></p><a id="more"></a><blockquote class="blockquote-center"><p>黄色的树林里分出两条路，<br>可惜我不能同时去涉足，<br>我在那路口久久伫立，<br>我向着一条路极目望去，<br>直到它消失在丛林深处。</p><p>但我却选了另外一条路，<br>它荒草萋萋，十分幽寂，<br>显得更诱人，更美丽；<br>虽然在这条小路上，<br>很少留下旅人的足迹。</p><p>那天清晨落叶满地，<br>两条路都未经脚印污染。<br>啊，留下一条路等改日再见！<br>但我知道路径延绵无尽头，<br>恐怕我难以再回返。</p><p>也许多少年后在某个地方，<br>我将轻声叹息将往事回顾：<br>一片树林里分出两条路——<br>而我选择了人迹更少的一条，<br>从此决定了我一生的道路。</p></blockquote><blockquote><p>《未选择的路》是美国诗人罗伯特·弗罗斯特创作的文学作品。这首深邃的哲理诗展现了现实生活中人们处在十字路口时难以抉择的心情。在诗中，诗人选择了一条人迹稀少、布满荆棘的道路，正如诗人在现实生话中选择了不会带来丰富物质的写诗生活。诗人在作出抉择后，同时又遗憾“鱼和熊掌不可兼得”，只能选择一条路，并坚定地走下去，只有在多年以后的回忆中轻叹遗憾。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>短文学</category>
      </categories>
      <tags>
        <tag>短文学</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 启动报错之 JDK 版本过低</title>
    <url>/archives/b2845630.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>启动 ElasticSearch 时报如下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RuntimeException[Java version: 1.7.0_40 suffers from critical bug https:&#x2F;&#x2F;bugs.openjdk.java.net&#x2F;browse&#x2F;JDK-8024830 which can cause data corruption.Please upgrade the JVM, see http:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;current&#x2F;_installation.html for current recommendations.If you absolutely cannot upgrade, please add -XX:-UseSuperWord to the JVM_OPTS environment variable.</span><br><span class="line">Upgrading is preferred, this workaround will result in degraded performance.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h2><p>经排查发现系统已安装 jdk1.7.0_79,但是 /usr/bin/java 的软链接指向了 <code>/etc/alternatives/java</code>，而 <code>/etc/alternatives/java</code> 却又指向 <code>/usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java</code>，导致 ElasticSearch识别的是 jdk1.7.0 版本的 JDK。</p><blockquote><p>openjdk 是 Linux 系统安装时附带的</p></blockquote><h2 id="三、问题解决"><a href="#三、问题解决" class="headerlink" title="三、问题解决"></a>三、问题解决</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/java/jdk1.7.0_79/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><h3 id="方法二-建议"><a href="#方法二-建议" class="headerlink" title="方法二(建议)"></a>方法二(建议)</h3><p>添加 jdk1.7.0_79 的 Link 值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/java java /usr/java/jdk1.7.0_79/bin/java 999999</span><br></pre></td></tr></table></figure><p>选择一个 Link 值：即选择一个版本的 Java</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-alternatives --config java</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>faq</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7 配置日志审计</title>
    <url>/archives/2656779.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>数据库开启日志审计可以记录用户访问数据库的行为。</p><a id="more"></a><h2 id="一、查询审计配置情况"><a href="#一、查询审计配置情况" class="headerlink" title="一、查询审计配置情况"></a>一、查询审计配置情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global variables like &#39;log_timestamps&#39;;</span><br><span class="line">mysql&gt; show global variables like &#39;%general%&#39;</span><br></pre></td></tr></table></figure><h2 id="二、永久开启审计"><a href="#二、永久开启审计" class="headerlink" title="二、永久开启审计"></a>二、永久开启审计</h2><p>在 <code>/etc/my.cnf</code> 中添加下述配置，可 <code>vim /etc/my.cnf</code> 打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log &#x3D; on</span><br><span class="line">general_log_file &#x3D; &#x2F;var&#x2F;log&#x2F;generalLog.log</span><br><span class="line">log_timestamps &#x3D; SYSTEM</span><br></pre></td></tr></table></figure><blockquote><p>general_log：on 为开启；off 为关闭<br>general_log_file：审计信息存储位置</p></blockquote><h2 id="三、临时开启审计"><a href="#三、临时开启审计" class="headerlink" title="三、临时开启审计"></a>三、临时开启审计</h2><p>在 MySQL 中执行以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global general_log &#x3D; on;</span><br><span class="line">mysql&gt; set global general_log_file &#x3D; &#x2F;var&#x2F;log&#x2F;generalLog.log</span><br><span class="line">mysql&gt; set global log_timestamps &#x3D; SYSTEM;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日志审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 实现文件 ZIP 压缩并解决中文文件名乱码</title>
    <url>/archives/c5372dcb.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>本文介绍的是用 Java 实现文件 ZIP 压缩以及解决中文文件名乱码问题。</p><a id="more"></a><h2 id="一、文件压缩的中文乱码问题"><a href="#一、文件压缩的中文乱码问题" class="headerlink" title="一、文件压缩的中文乱码问题"></a>一、文件压缩的中文乱码问题</h2><h3 id="1、中文文件名的乱码解决"><a href="#1、中文文件名的乱码解决" class="headerlink" title="1、中文文件名的乱码解决"></a>1、中文文件名的乱码解决</h3><p>对于压缩的文件，当文件名称是中文时，若使用 <strong>JDK API 中自带的类（java.util.zip.ZipEntry; java.util.zip.ZipOutputStream;）</strong>进行压缩，压缩完成后，可以看到压缩包中的文件名称是乱码(文件的内容无乱码问题)。此时只要用 <strong>ANT 中的 ant.jar 中的类（org.apache.tools.zip.ZipEntry; org.apache.tools.zip.ZipOutputStream;）</strong>就可以解决此问题。</p><h3 id="2、ant-jar-依赖"><a href="#2、ant-jar-依赖" class="headerlink" title="2、ant.jar 依赖"></a>2、ant.jar 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ant.jar 用于解决文件解压缩乱码问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、JAVA-实现-ZIP-压缩源代码"><a href="#二、JAVA-实现-ZIP-压缩源代码" class="headerlink" title="二、JAVA 实现 ZIP 压缩源代码"></a>二、JAVA 实现 ZIP 压缩源代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.tools.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.tools.zip.ZipOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * zip压缩工具包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Class</span> ZipUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipUtils</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ZipUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">2</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 压缩成ZIP</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> srcFilePath 压缩文件路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tarFilePath 目标 ZIP 输出路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> KeepDirStructure 是否保留原来的目录结构,true:保留目录结构;</span></span><br><span class="line"><span class="comment">	 *            false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception 压缩失败会抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">toZip</span><span class="params">(String srcFilePath, String tarFilePath, <span class="keyword">boolean</span> KeepDirStructure)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isCompressSuccess = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		ZipOutputStream zos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			File sourceFile = <span class="keyword">new</span> File(srcFilePath);</span><br><span class="line">			<span class="keyword">if</span> (!sourceFile.exists()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"待压缩文件 ["</span> + srcFilePath + <span class="string">"]不存在."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(tarFilePath));</span><br><span class="line">			zos = <span class="keyword">new</span> ZipOutputStream(fos);</span><br><span class="line">			<span class="comment">// 设置压缩的编码，解决压缩路径中的中文乱码问题</span></span><br><span class="line">			zos.setEncoding(<span class="string">"UTF-8"</span>);            </span><br><span class="line">			compress(sourceFile, zos, sourceFile.getName(), KeepDirStructure);</span><br><span class="line">			isCompressSuccess = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			logger.info(<span class="string">"【文件压缩】 压缩完成，耗时：&#123;&#125; ms"</span>, (end - start));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.error(<span class="string">"【文件压缩】 压缩失败"</span>, e);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件压缩失败"</span>, e);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			closeOutPutStream(zos);</span><br><span class="line">			closeOutPutStream(fos);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isCompressSuccess;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归压缩方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sourceFile 源文件</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> zos zip输出流</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name 压缩后的名称</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> KeepDirStructure 是否保留原来的目录结构,true:保留目录结构;</span></span><br><span class="line"><span class="comment">	 *            false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(File sourceFile, ZipOutputStream zos, String name, <span class="keyword">boolean</span> KeepDirStructure)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">		<span class="keyword">if</span> (sourceFile.isFile()) &#123;</span><br><span class="line">			<span class="comment">// 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字</span></span><br><span class="line">			zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name));</span><br><span class="line">			<span class="comment">// copy文件到zip输出流中</span></span><br><span class="line">			<span class="keyword">int</span> len;</span><br><span class="line">			FileInputStream in = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">			<span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				zos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			zos.closeEntry();</span><br><span class="line">			in.close();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			File[] listFiles = sourceFile.listFiles();</span><br><span class="line">			<span class="keyword">if</span> (listFiles == <span class="keyword">null</span> || listFiles.length == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 需要保留原来的文件结构时,需要对空文件夹进行处理</span></span><br><span class="line">				<span class="keyword">if</span> (KeepDirStructure) &#123;</span><br><span class="line">					<span class="comment">// 空文件夹的处理</span></span><br><span class="line">					zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name + <span class="string">"/"</span>));</span><br><span class="line">					<span class="comment">// 没有文件，不需要文件的copy</span></span><br><span class="line">					zos.closeEntry();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (File file : listFiles) &#123;</span><br><span class="line">					<span class="comment">// 判断是否需要保留原来的文件结构</span></span><br><span class="line">					<span class="keyword">if</span> (KeepDirStructure) &#123;</span><br><span class="line">						<span class="comment">// 注意：file.getName()前面需要带上父文件夹的名字加一斜杠,</span></span><br><span class="line">						<span class="comment">// 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了</span></span><br><span class="line">						compress(file, zos, name + <span class="string">"/"</span> + file.getName(), KeepDirStructure);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						compress(file, zos, file.getName(), KeepDirStructure);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 释放资源</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Title</span> closeOutPutStream</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ops</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeOutPutStream</span><span class="params">(OutputStream ops)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ops != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ops.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">				logger.error(<span class="string">"关闭输出流失败"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>文件压缩</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 服务启动失败</title>
    <url>/archives/23592fef.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>启动 MySQL 服务报 starting MySQL….the server quit without updating PID file [failed]sqldata/MySQL.pid</p><a id="more"></a><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>通过分析 mysqld.log 日志信息发现服务启动过程中有几处 ERROR 提示，信息如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-07-26T02:07:28.316099Z 0 [ERROR] Could not create unix socket lock file &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;tmp&#x2F;mysql.sock.lock.  </span><br><span class="line">2016-07-26T02:07:28.316115Z 0 [ERROR] Unable to setup unix socket lock file.  </span><br><span class="line">2016-07-26T02:07:28.316128Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure><p>分析日志提示可能是由于不能创建 socket lock 文件导致终止了，到对应的目录下面看了下，发现在 MySQL 没有启动的时候有-rw——-. 1 mysql mysql 6 Oct 17 10:00 mysql.sock.lock这个文件存在，所以应该是由于存在了sock的锁文件，导致启动的时候不能创建该文件导致MYSQL启动失败。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p><strong>删除或改名备份</strong>后，再次启动正常。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>faq</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 @RequestPart 同时接收表单数据和 MultipartFile 数据</title>
    <url>/archives/d901f37d.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>项目中有使用 RestTemplate 转发表单数据和上传文件，之前都是将表单数据 Json 传到后台进行反序列化，这样一来代码就显得十分不美观，后来发现使用 <strong>@RequestPart</strong> 注解可直接进行数据绑定，十分优雅地解决了这个问题。</p><a id="more"></a><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(FormData formData, MultipartFile[] files)</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; multiValueMap = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        multiValueMap.add(<span class="string">"formData"</span>, formData);</span><br><span class="line">        List&lt;Resource&gt; tmpResource = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmpResource.add(multipartFile.getResource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        multiValueMap.addAll(<span class="string">"files"</span>, tmpResource);</span><br><span class="line">        restTemplate.postForObject(<span class="string">"localhost:8080/demo/save"</span>, multiValueMap, Void<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上传 MultipartFile 形式文件时，需要用 <code>MultiValueMap&lt;String, Object&gt;</code> 类装载表单数据和文件对象。其中，文件对象需将 <code>multipartFile.getResource()</code> 的数据传递给 MultiValueMap。</p></blockquote><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(@RequestPart(required = <span class="keyword">false</span>)</span> FormData formData,</span></span><br><span class="line"><span class="function">                     @<span class="title">RequestParam</span><span class="params">(value=<span class="string">"files"</span>, required=<span class="keyword">false</span>)</span> MultipartFile[] files) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/a326a2ffafde" target="_blank" rel="noopener external nofollow noreferrer">https://www.jianshu.com/p/a326a2ffafde</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>restTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.5 下安装 MySQL5.7.14-RPM 方式</title>
    <url>/archives/409fb0bb.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>本文介绍的是 MySQL5.7.14 在 Centos6.5 下 RPM 方式的安装情况。</p><a id="more"></a><h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h3><blockquote><p>MySQL 版本：mysql-5.7.14-1.el6.x86_64.rpm-bundle.tar<br>操作系统：Centos6.5</p></blockquote><h3 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2.名词解释"></a>2.名词解释</h3><p><strong>文中出现的类似 <code>/opt</code> 等，均为本文安装时自定义配置信息，实际安装时请对号入座。</strong></p><blockquote><p><code>/opt</code> ：压缩包上传目录</p></blockquote><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1-检查是否已安装-MySQL-组件"><a href="#1-检查是否已安装-MySQL-组件" class="headerlink" title="1.检查是否已安装 MySQL 组件"></a>1.检查是否已安装 MySQL 组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>若查询显示存在 MySQL 组件，则执行下面语句卸载。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>卸载完了再检查一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><h3 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2.安装MySQL"></a>2.安装MySQL</h3><p>解压 MySQL 安装包，并 <code>rpm -ivh ***</code> 安装解压包里的组件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# cd /opt</span><br><span class="line">[root@Master opt]# tar -xvf mysql-5.7.14-1.el6.x86_64.rpm-bundle.tar</span><br><span class="line">[root@Master opt]# rpm -ivh mysql-community-common-5.7.14-1.el6.x86_64.rpm</span><br><span class="line">[root@Master opt]# rpm -ivh mysql-community-libs-5.7.14-1.el6.x86_64.rpm</span><br><span class="line">[root@Master opt]# rpm -ivh mysql-community-client-5.7.14-1.el6.x86_64.rpm</span><br><span class="line">[root@Master opt]# rpm -ivh mysql-community-server-5.7.14-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p><code>/opt</code> 为压缩包上传目录<br>一定要按顺序安装 mysql-community-common，mysql-community-libs 等组件，否则会报缺少依赖错误。</p></blockquote><h3 id="3-修改-MySQL-的配置文件"><a href="#3-修改-MySQL-的配置文件" class="headerlink" title="3.修改 MySQL 的配置文件"></a>3.修改 MySQL 的配置文件</h3><p>在 <code>/etc/my.cnf</code> 中配置字符集等参数，可用 <code>vim /etc/my.cnf</code> 打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在[mysqld]下面添加</span><br><span class="line">character-set-server&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">在[client]下面添加</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><h3 id="4-设置服务开机启动"><a href="#4-设置服务开机启动" class="headerlink" title="4.设置服务开机启动"></a>4.设置服务开机启动</h3><p>查看 MySQL 是否自启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# chkconfig --list | grep mysqld</span><br></pre></td></tr></table></figure><p>设置服务开机启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# chkconfig mysqld on</span><br></pre></td></tr></table></figure><h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# service mysqld start</span><br></pre></td></tr></table></figure><h3 id="6-修改初始密码并设置远程登录"><a href="#6-修改初始密码并设置远程登录" class="headerlink" title="6.修改初始密码并设置远程登录"></a>6.修改初始密码并设置远程登录</h3><p>获取初始密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>以 root 用户登录 MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# mysql -u root -p</span><br></pre></td></tr></table></figure><p>修改 root 用户本地登录密码，第一次设置初始密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set password for root@localhost&#x3D;password(&quot;新密码&quot;);</span><br></pre></td></tr></table></figure><p>创建远程登录用户 root</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;密码&#39;;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>退出 MySQL 终端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>使用 Navicat Premium 12、SQLyog 等客户端工具连接数据库进行连通性测试。若提示连接成功，则表明 MySQL 安装完毕。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.5 下安装 MySQL5.7.11-TAR 方式</title>
    <url>/archives/c121720d.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>本文介绍的是 MySQL5.7.11 在 Centos6.5 下 TAR 方式的安装情况。</p><a id="more"></a><h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h3><blockquote><p>MySQL版本：mysql-5.7.11-linux-glibc2.5-x86_64.tar<br>操作系统：Centos6.5</p></blockquote><h3 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2.名词解释"></a>2.名词解释</h3><p><strong>文中出现的类似 <code>/opt</code> ，<code>/app/MySQL</code> ，<code>/app/mysqldata</code> 等，均为本文安装时自定义配置信息，实际安装时请对号入座。</strong></p><blockquote><p><code>{MYSQL_BASE_DIR}</code>：MySQL的安装目录，本文为 <code>/app/MySQL</code><br><code>{MYSQL_DATA_DIR}</code>：MySQL的数据文件目录，本文为 <code>/app/mysqldata</code><br><code>/opt</code> ：压缩包上传目录</p></blockquote><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1-检查是否已安装-MySQL-组件"><a href="#1-检查是否已安装-MySQL-组件" class="headerlink" title="1.检查是否已安装 MySQL 组件"></a>1.检查是否已安装 MySQL 组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><p>若查询显示存在 MySQL 组件，则执行下面语句卸载。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -e --nodeps mysql</span><br></pre></td></tr></table></figure><p>卸载完了再检查一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# rpm -qa | grep mysql</span><br></pre></td></tr></table></figure><h3 id="2-创建用户及用户组"><a href="#2-创建用户及用户组" class="headerlink" title="2.创建用户及用户组"></a>2.创建用户及用户组</h3><blockquote><p>本文用户及用户组均为 mysql</p></blockquote><p>删除用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# userdel mysql</span><br></pre></td></tr></table></figure><p>删除用户组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# groupdel mysql</span><br></pre></td></tr></table></figure><p>创建名为 mysql 的用户组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# groupadd mysql</span><br></pre></td></tr></table></figure><p>在用户组 mysql 下创建名为 mysql 的用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# useradd -g mysql mysql</span><br></pre></td></tr></table></figure><h3 id="3-解压安装包"><a href="#3-解压安装包" class="headerlink" title="3.解压安装包"></a>3.解压安装包</h3><p>解压 MySQL 安装包，并将解压包里的文件拷贝至 MySQL 的安装目录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master ~]# cd /opt</span><br><span class="line">[root@Master opt]# tar -xvf mysql-5.7.11-linux-glibc2.5-x86_64.tar</span><br><span class="line">[root@Master opt]# tar -zxvf mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz</span><br><span class="line">[root@Master opt]# cp -r mysql-5.7.11-linux-glibc2.5-x86_64 /app/MySQL</span><br></pre></td></tr></table></figure><blockquote><p><code>/opt</code> 为压缩包上传目录<br><code>/app/MySQL</code> 为 MySQL 安装目录</p></blockquote><h3 id="4-初始化数据库"><a href="#4-初始化数据库" class="headerlink" title="4.初始化数据库"></a>4.初始化数据库</h3><p>切换系统用户 mysql ，初始化数据库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master opt]# su - mysql</span><br><span class="line">[root@Master ~]# cd /app/MySQL</span><br><span class="line">[root@Master MySQL]# ./bin/mysqld --user=mysql --basedir=/app/MySQL --datadir=/app/mysqldata --initialize</span><br></pre></td></tr></table></figure><p>下图中红色方框内的随机密码，在修改密码时要用到，请先保存。</p><p><img src="/archives/c121720d/mysql%E5%AE%89%E8%A3%85%E5%AF%86%E7%A0%81.png" alt></p><h3 id="5-创建软连接"><a href="#5-创建软连接" class="headerlink" title="5.创建软连接"></a>5.创建软连接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# ln -s /app/MySQL/bin/mysql /usr/bin/mysql</span><br></pre></td></tr></table></figure><h3 id="6-修改-MySQL-的配置文件"><a href="#6-修改-MySQL-的配置文件" class="headerlink" title="6.修改 MySQL 的配置文件"></a>6.修改 MySQL 的配置文件</h3><p>拷贝 <code>{MYSQL_BASE_DIR}/support-files/my-default.cnf</code> 作为 MySQL 的配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# cp /app/MySQL/support-files/my-default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure><p>在 <code>/etc/my.cnf</code> 中配置字符集 basedir、datadir 等参数，可用 <code>vim /etc/my.cnf</code> 打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir&#x3D;&#x2F;app&#x2F;MySQL</span><br><span class="line">datadir&#x3D;&#x2F;app&#x2F;mysqldata</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">character-set-server&#x3D;utf8mb4</span><br><span class="line">log_error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">log_timestamps&#x3D;SYSTEM</span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><blockquote><p>basedir：MySQL 的安装目录，本文为 <code>/app/MySQL</code><br>datadir：MySQL 的数据文件目录，本文为 <code>/app/mysqldata</code><br>log_timestamps：MySQl5.7.2 中新增的参数，用于控制 error_log、slow_log、genera log 等记录日志的显示时间，默认为 <code>UTC</code> ，本文为 <code>SYSTEM</code></p></blockquote><h3 id="7-设置服务开机启动"><a href="#7-设置服务开机启动" class="headerlink" title="7.设置服务开机启动"></a>7.设置服务开机启动</h3><p>拷贝 <code>{MYSQL_BASE_DIR}/support-files/mysql.server</code> 作为启动脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# cp /app/MySQL/support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure><p>在 <code>/etc/init.d/mysql</code> 中设置 basedir 和 datadir，可用 <code>vim /etc/init.d/mysql</code> 打开</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basedir &#x3D;&#x2F;app&#x2F;MySQL</span><br><span class="line">datadir&#x3D;&#x2F;app&#x2F;mysqldata</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# chkconfig mysql on</span><br></pre></td></tr></table></figure><h3 id="8-设置MySQL-服务的启停"><a href="#8-设置MySQL-服务的启停" class="headerlink" title="8.设置MySQL 服务的启停"></a>8.设置MySQL 服务的启停</h3><p>这一步只需启动 MySQL 服务即可</p><p>启动服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# service mysql start</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# service mysql restart</span><br></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# service mysql stop</span><br></pre></td></tr></table></figure><h3 id="9-修改-root-用户的密码"><a href="#9-修改-root-用户的密码" class="headerlink" title="9.修改 root 用户的密码"></a>9.修改 root 用户的密码</h3><p>以 root 用户登录 MySQL，输入第 4 步的随机密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Master MySQL]# mysql -uroot -p</span><br></pre></td></tr></table></figure><p>修改 root 用户本地登录密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">mysql&gt; set password for root@localhost&#x3D;password(&#39;新密码&#39;);</span><br></pre></td></tr></table></figure><p>创建远程登录用户 root</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;密码&#39;;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>退出 MySQL 终端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>使用 Navicat Premium 12、SQLyog 等客户端工具连接数据库进行连通性测试。若提示连接成功，则表明 MySQL 安装完毕。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<!-- build time:Sun Mar 29 2020 16:57:06 GMT+0800 (GMT+08:00) --><p>其实很早之前就有搭建个人博客的想法了，但由于没有找到自己喜欢的主题（其实就是懒~）。。。所以就一直没有行动起来。</p><p>直到最近浏览到 <a href="https://notes.iissnan.com/" target="_blank" rel="noopener external nofollow noreferrer">IIssNan’s Notes</a> 这个网站，瞬间被这简单大气的主题风格所吸引。。。所以今天 <a href="https://www.aiakos.cn">随风</a> 诞生了，我将在这里记录个人的成长点滴。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
